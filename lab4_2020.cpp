/*************************************************************
	Практическое занятие №4. Встроенные массивы.
							Простейшие алгоритмы сортировки и поиска.
							
*************************************************************/

#include <cstdlib>
#include <ctime>
#include <iostream>

#define	  stop __asm nop

int main()
//Задания, помеченные * не являются обязательными. Но выполнение их крайне желательно!!!
{
///////////////////////////////////////////////////////////////
//			Указатели (продолжение)                              
///////////////////////////////////////////////////////////////

		//Задание 1. Модификатор const. 
		//В каждом из заданий объявите указатель требуемого вида. 
		//Посредством каждого указателя попробуйте:
		//1) получить значение по адресу
		//2) записать новое значение по адресу
		//3) модифицировать указатель
//Замечания:
//1.операторы явного преобразования типа использовать не следует
//2.если компилятор не позволяет выполнить операцию, то комментируйте эту строку с пояснением

	int val = 123;
	
		//Задание 1a. Указатель является константой. 
	{

		int* const c_ptr = &val;	//константный указатель должен быть инициализирован при объявлении
		std::cout << *c_ptr << std::endl;
		*c_ptr = 789;
		// c_ptr++;	// нельзя изменить значение самого *const.
		
		
	}
	
	val = 123;	// - восстановил значение, измененное с помощью c_ptr

	stop


		//Задание 1б. Указываемое значение является константой.
	{
		const int* nc_ptr=&val;
		std::cout << *nc_ptr << std::endl;
		//*nc_ptr = 789; - нельзя изменить значение по указателю const*
		nc_ptr++;
	
	}

		stop

		// *******************************************************


				//Задание 1в. И указатель, и указываемое значение
				//являются константами. 
	{
		const int* const cc_ptr = &val;
		std::cout << *cc_ptr<<std::endl;
		//*cc_ptr = 789; и сам указатель 
		//cc_ptr++;		 и указываемое значение нельзя модицировать
	}
	stop

// *******************************************************


		//Задание 1г. Указатель на переменную, объявленную с
		//ключевым словом const. 
	const int nN = 1;

	//Объявите указатель и проинициализируйте его выражением - &nN	
	const int* nN_ptr = &nN;
	
	std::cout << *nN_ptr;	
	//*nN_ptr = 789; - нельзя модифицировать значение - указываем на const
	nN_ptr++;
	
	stop


// *******************************************************

	//Задание 2. Явное преобразование указателя. 
	//Иногда возникает необходимость одни и те же данные интерпретировать по-разному,

	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 

	//Следовательно, возникает необходимость явного преобразования указателя. 

	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне

	//переменных и изменяйте пункт - Hexadecimal display !!!!!!!!!!!!!!!!!


	unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание на сообщение компилятора 
	//- он не считает преобразование "легальным" (безопасным)

	unsigned char* pucObject5;

	//pucObject5=static_cast<unsigned char*>(pnObject5);	//(1)   'static_cast': cannot convert from 'unsigned int *' to 'unsigned char *'
		

	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2)

	//Откомментируйте (!) следующие строчки следующим образом:
	// сс=..., 	pucObject5 - изменился? 	*pucObject5=...

	char cc = *(pucObject5++);	//	cc=0x88,  pucObject5 -не изменился, *pucObject5=0x77;
	cc = (*pucObject5)++;		// cc=0x77, pucObject5 -изменился, *pucObject5=0x78

	cc = ++*(pucObject5);		// сс=0x79, pucObject5 - не изменился,  *pucObject5=0х79;
	cc = *(++pucObject5);		// сс=0х66, pucObject5 - изменился, *pucObject5= 0х66;
	stop

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               
///////////////////////////////////////////////////////////////

	//Задание 3. 
	//Имеется одномерный встроенный массив, проинициализированный при объявлении 
	//Отсортируйте массив по возрастанию значений. 
	//Используйте "пузырьковую" сортировку  
	// Правильность решения проверьте с помощью отладчика

	{
		int ar[] = { 5, 4, 7,  8, 1, 2, 6, 0, 10, 12, 77, 11,
					  6, 8, 33, 21, 1, 2, 3, 4};


	
	for (int i = 0; i < (sizeof(ar) / sizeof(ar[0])) - 1; i++)
	{
				
		for (int g = 0; g < (sizeof(ar) / sizeof(ar[0])) - i - 1; g++)
		{
			if (ar[g] > ar[g+1]) {
				std::swap(ar[g], ar[g+1]);
				}
		}
		
	}
	
	stop;

	}
	
	
// *******************************************************
	//Задание 4  
	//в)Инициализация массива строковыми литералами:
	//Объявите массив указателей и проинициализируйте его строковыми литералами . 
	//Выведите  массив на печать.
	const char* Arr[] = {"Abc","cde","fgh"};

	std::cout << std::endl;
	for (int i = 0; i < sizeof(Arr)/sizeof(Arr[0]); i++)
	{
		std::cout << Arr[i]<<std::endl;
	}

// *******************************************************
	//Задание 5. 
	//a) Объявите одномерный неинициализированный массив ( размером N)
	//Задайте значения элементов с помощью генератора случайных чисел.
		
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	// int tmp= rand(); // получим случайное значение в диапазоне от 0 до RAND_MAX
    	//значение RAND_MAX задано в файле <stdlib.h>  и равно  0x7fff
	
	//если Вам требуется задать иные границы диапазона при генерации случайного числа, 
	//то это можно сделать так:
	//v1 = rand() % 100;         // v1 в диапазоне 0 - 99
	//v2 = rand() % 100 + 1;     // v2 в диапазоне 1 - 100
	//v3 = rand() % 30 + 1985;   // v3 в диапазоне 1985-2014 
	
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	//srand( time( 0 ) );
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)
	{
		std::cout << std::endl;
		srand(time(0));

		int const N = 10;

		int Ar1[N];

		for (int i = 0; i < 10; i++)
		{
			Ar1[i] = rand() % 100 + 1;
		}



		//б) Выведите массив на печать

		for (int i = 0; i < 10; i++)
		{
			std::cout << Ar1[i] << ' ';
		}
		std::cout << std::endl;
		//в)Отсортируйте массив по убыванию значений. 
		//Используйте сортировку "выбором"


		for (int i = 0; i < N; i++)
		{
			int min_index = i;

			for (int j = i + 1; j < N; j++)
			{
				if (Ar1[j] < Ar1[min_index])
				{
					min_index = j;
				}
			}
			if(min_index!=i) 	std::swap(Ar1[i], Ar1[min_index]);

		}
		stop
	}
	



		// 

		// *******************************************************

			//Задание 7. 
			//Объявите встроенный одномерный массив, состоящий из N элементов целого типа. 
	{
		int const N = 10;

		int Ar[N];
	//Напишите фрагмент кода, который вводит целые числа с помощью
	//потока ввода в объявленный Вами массив, каждый раз ( на каждой итерации)
	//упорядочивая полученное значение по возрастанию.
	//Для проверки выводите массив на консоль на каждой итерации
		
			int lvl = 0; // уровень заполненности массива
					
			for (int i = 0; i < N; i++)
			{
				std::cout << "Enter Ar[" << i << ']' << '\n';
				std::cin >> Ar[i];
				lvl++;

				if ((i != 0) && (Ar[i] < Ar[i - 1]))
				{

					for (int j = 0; j < lvl-1; j++)
					{
						
							if (Ar[j] > Ar[i])
							{
								std::swap(Ar[j], Ar[i]);
							}
						
					}
				}

							
				std::cout << "sorted:" << '\n';			
				for (int iii = 0; iii < lvl; iii++)
				{
					std::cout << Ar[iii] << '\t';
				}
				std::cout << "\n\n";
			}
		}
		stop
	
// *******************************************************
	//Задание 8. 

	//Простой поиск.
	//Модифицируйте предыдущее задание следующим образом:
	//очередное введенное значение помещается в массив только при условии, 
	//что там еще такого нет (то есть дубли игнорируются)
		{
			int const N = 10;

			int Ar[N];

			int lvl = 0; // уровень заполненности массива
			int input_num;

			for (int i = 0; i < N; i++)
			{
				bool flag = 0;
				std::cout << "Enter Ar[" << i << ']' << '\n';
				std::cin >> input_num;

				for (int j = 0; j < lvl; j++) //проверка введенного числа на дубль
				{
					if (Ar[j] == input_num)
					{
						std::cout << "\nAlready used\n";
						flag = 1;
						break;

					}

				}

				if (!flag)
				{
					Ar[i] = input_num;
					lvl++;
					//сортировка от 0 до lvl
					if ((i != 0) && (Ar[i] < Ar[i - 1]))
					{

						for (int j = 0; j < lvl - 1; j++)
						{
							for (int g = 0; g < lvl - j - 1; g++)
							{
								if (Ar[g] > Ar[g + 1])
								{
									std::swap(Ar[g], Ar[g + 1]);
								}
							}
						}
					}

					std::cout << "sorted:" << '\n';
					for (int i = 0; i < lvl; i++)
					{
						std::cout << Ar[i] << '\t';
					}
					std::cout << "\n\n";
				}
				else i--;

			}
			stop
		}
		
// *******************************************************
	//Задание 9
	//Объявите одномерный встроенный массив элементов типа char.

{
		const int N = 10;
		char Ar[N];
	//Сформируйте значения элементов массива с помощью генератора случайных 
	//чисел таким образом, чтобы в массиве были только символы '*'  и '_'  
		
		for (int i = 0; i < N; i++)
		{
			if (rand() % 2)
				Ar[i] = '*';
			else Ar[i] = '_';
		}

		std::cout << "\nBefore\n";
		for (int i = 0; i < N; i++)
		{
			std::cout << Ar[i]<<'\t';
		}
		

		
		int left = 0, right = N - 1;

		while(left<right)
		{
			if (Ar[left] == '*')
			{
				left++;
				continue;
			}

			if (Ar[right] == '_')
			{
				right--;
				continue;
			}

			std::swap(Ar[left], Ar[right]);
			left++;
			right--;
			
		}

		std::cout << "\nAfter\n";
		for (int i = 0; i < N; i++)
		{
			std::cout << Ar[i] << '\t';
		}

}
		stop

		
	//"сдвиньте звездочки" в начало массива, например:
	//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
	//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
	//и распечатайте массив 
//(Подсказки в файле Алгоритмы для лабораторной работы_4. pdf)

// *******************************************************
	//Задание 10
	//объявите одномерный встроенный массив  из N элементов и проинициализируйте его.
	{
		int const N = 6;
		int Ar[N] = { 5, 2, 11, 4, 23, 9 };
		//а) сдвиньте все элементы массива вправо на 1 позицию

		for (int i = N - 1; i >= 0; i--)
		{
			Ar[i + 1] = Ar[i];
		}
		Ar[0] = 0;
		stop
	}

		//б) (Циклическая перестановка). Сдвиньте все элементы массива вправо на 1 позицию , 
		//но последний элемент не должен быть утерян. Его следут переместить в начало.
		//например,  { 5, 2, 11, 4, 23, 9 } ->  {9, 5, 2, 11, 4, 23 }
	{
		int const N = 6;
		int Ar[N] = { 5, 2, 11, 4, 23, 9 };
		
		int temp = Ar[N - 1];
		for (int i = N - 1; i >= 0; i--)
		{
			Ar[i + 1] = Ar[i];
		}
		Ar[0] = temp;
		stop
	}
		//в)(Кольцевой буфер) выведите массив на печать, циклически сдвинув элементы вправо на 1 позицию.
		//При решении задачи не следует перемещать элементы массива, а надо использовать кольцевой буфер.
		// Одномерный массив можно "свернуть" в кольцо и считать, что за последним элементом следует начальный и
		// потом установить "новое" начало массива.
	{
		std::cout << std::endl;
		int const N = 6;
		int Ar[N] = { 5, 2, 11, 4, 23, 9 };
		
		
		for (int i = 1; i <=N;  i++)
		{
			std::cout << Ar[(N+i)%N]<<'\t';
		}
		
		stop
	}
// *******************************************************
	//Задание 11 (*)
	//алгоритм "тасования колоды"
	//объявите одномерный встроенный массив  из N элементов и 
	// заполните  его неповторяющимися числами из заданного отрезка 
	//натурального ряда, расположенными в случайном порядке
//(Подсказки в файле Алгоритмы для лабораторной работы_4.pdf)
//Алгоритм:
//Массив  A [N] инициализируется последовательными значениями из отрезка, например [0,N-1]
//index=N-1, где index- максимальное значение индекса.

//В цикле по index выполняется перемешивание значений:
//	1. Генерируется случайное число  R из отрезка [0, index]
//	2. Выполняется обмен значений A[index]  и  A[R]
//	3. index=index -1
//	4. Если index==0, то конец
//	5. Переход к шагу 1
	{
		const int N = 10;
		int Ar[N];
		for (int i = 0; i < N; i++)	
		{
			Ar[i] = i + 1;
		}

		std::cout << "\nArray before mix\n";
		for (int i = 0; i < N; i++)	
		{
			std::cout << Ar[i] << '\t';
		}

		std::cout << '\n';

		int index = N - 1;

		while (index)	//	перетасовка
		{
			std::swap(Ar[index], Ar[rand() % (index + 1)]);
			index--;
		}

		std::cout << "\nArray after mix\n";
		for (int i = 0; i < N; i++)
		{
			std::cout << Ar[i] << '\t';
		}

		stop
	}
// *******************************************************

}